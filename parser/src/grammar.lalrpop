// vi: ft=rust
use std::str::FromStr;
use crate::{
    pos::{self, HasSpan, Spanned},
    ast::*,
};

// grammar<'err>(errors: &'err mut Vec<lalrpop_util::ParseError<usize, Token<'input>, parser::Error>>);
grammar;

// A bunch of macros.

Sp<Rule>: Spanned<Rule> =
    <l: @L> <rule: Rule> <r: @R> =>
        pos::spanned2(l, r, rule);

Semi<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// Comma-delimited with minimum zero elements.
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// Comma-delimited with minimum one element.
CommaOnce<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};

Pipe<T>: Vec<T> = {
    <v:(<T> "|")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// Common patterns.

Quote: String = {
    r#""[^"]*""# => {
      let a = <>;
      a[1..a.len()-1].to_string()
    }
};

SingleQuote: String = {
    r"'[^']*'" => {
      let a = <>;
      a[1..a.len()-1].to_string()
    }
};

Ident: Ident = {
    r"([a-z_]+[a-zA-Z0-9_]*)" => Ident(String::from_str(<>).unwrap()),
};

// Note: we only have signed integers for now.
Int: i64 = {
    r"-?0x[0-9A-Fa-f][0-9A-Fa-f_]*" => i64::from_str_radix(&str::replace(&<>[2..], "_", ""), 16).unwrap(),
    r"-?0b[01][01_]+" => i64::from_str_radix(&str::replace(&<>[2..], "_", ""), 2).unwrap(),
    r"-?[0-9][0-9_]*" => i64::from_str(&str::replace(<>, "_", "")).unwrap(),
};

Bool: bool = {
    "true" => true,
    "false" => false,
}

// Statement: var definition or expression

pub Module: Module = {
    Statement* => Module {
        statements: <>,
    }
}


FnStatement: Statement = {
    "fn" <i:Ident> "(" <a:Comma<Expr>> ")" "{" <e:Expr+> "}" => Statement::Fn {
        name: i,
        args: a,
        body: e,
    },
};


pub Statement: Statement = {
    FnStatement,
    Expr => Statement::Expression(<>),
};

LetExpr: Expr = {
    // let x = 1
    "let" <i:Ident> "=" <e:Expr> => Expr::Let {
        name: i,
        ty: None,
        value: Box::new(e),
    },

    // let x : int = 1
    "let" <i:Ident> ":" <t:Ident> "=" <e:Expr> => Expr::Let {
        name: i,
        ty: Some(t),
        value: Box::new(e),
    }
}

IfExpr: Expr = {
    "if" <cond:OpExpr> "{" <i:OpExpr> "}" "else" "{" <e:OpExpr> "}" => Expr::If (
        Box::new(cond),
        Box::new(i),
        Box::new(e),
    ),
}

pub Expr: Expr = {
    OpExpr,
    LetExpr,
    LambdaExpr,
    IfExpr,
};

CallExpr: Expr = {
    // <i:Ident> "()" => Expr::Call{
    //     name: i,
    //     args: Vec::new(),
    // },

    <i:Ident> "(" <a:Comma<OpExpr>> ")" => Expr::Call{
        name: i,
        args: a,
    }
};

LambdaExpr: Expr = {
    "fn" "(" <a:Comma<Ident>> ")" "{" <e:Expr+> "}" => Expr::Lambda {
        args: a,
        body: e,
    },
};

// Operator precedence or, and, eq, compare (<, <=, >, >=), pipe, add (+, -, +.? -.?), factor (*, /)
//
// strong to weak
// ?
// unary -/*/!/&/&mut
// * / %
// + -
// << >>
// &
// ^
// |
// == != < > <= >= needs parens
// &&
// ||
// .. ..=
// = += -= *= /= %= &= |= ^= <<= >>= right to left

Tier<Op,NextTier>: Expr = {
    <l:Tier<Op,NextTier>> <op:Op> <r:NextTier> => Expr::Op(Box::new(l), op, Box::new(r)),
    NextTier => <>
};

OpExpr = Tier<OrOp, And>;
And = Tier<AndOp, Cmp>;
Cmp = Tier<CmpOp, Bor>;
// TODO: Bxor
Bor = Tier<BorOp, Band>;
Band = Tier<BandOp, Arith>;
// TODO: Shift
Arith = Tier<ArithOp, Factor>;
Factor = Tier<FactorOp, Term>;
// TODO: unary

UnaryOp: Opcode = {
    "!" => Opcode::Not,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

ArithOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

BandOp: Opcode = {
    "&" => Opcode::Band,
};

BorOp: Opcode = {
    "|" => Opcode::Bor,
};

CmpOp: Opcode = {
    "==" => Opcode::Equal,
    "!=" => Opcode::NotEqual,
    "<" => Opcode::Less,
    ">" => Opcode::Greater,
    "<=" => Opcode::LessEqual,
    ">=" => Opcode::GreaterEqual,
};

AndOp: Opcode = {
    "&&" => Opcode::And,
};

OrOp: Opcode = {
    "||" => Opcode::Or,
};

// ExprProjection => select(record field), apply, lambda (decl) or AtomExpr
Term: Expr = {
    CallExpr => <>,
    AtomExpr => <>,
};

// TODO: shift assign

AtomExpr: Expr = {
    // symbol
    Ident => Expr::Var(<>),
     "()" => Expr::Unit,
    Int => Expr::Int(<>),
    Bool => Expr::Bool(<>),
    // "(" <Expr> ")",
    // float
    // string,
    // char,
    // tuple
    // record
    // byte,
    // ! => { errors.push(<>.error); ast::Expression::Unknown },
};
